use std::path::Path;

/// Generate the wrapper shell script content for a GSD project.
/// This script is shared by all phases — each crontab entry passes the phase number as an argument.
pub fn generate_wrapper_script(project_path: &Path) -> String {
    let project = project_path.display();

    format!(
        r##"#!/usr/bin/env bash
# gsd-cron wrapper script
# Generated by gsd-cron for project: {project}
# Usage: gsd-cron-wrapper.sh <phase_number>

set -euo pipefail

PHASE="$1"
PROJECT="{project}"
PLANNING_DIR="$PROJECT/.planning"
PHASES_DIR="$PLANNING_DIR/phases"
LOG_DIR="$PLANNING_DIR/logs"

mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/phase-$PHASE.log"

log() {{
    echo "[$(date -u '+%Y-%m-%dT%H:%M:%SZ')] $*" >> "$LOG_FILE"
}}

# Zero-pad phase number for directory matching
pad_phase() {{
    local phase="$1"
    if [[ "$phase" == *.* ]]; then
        local int_part="${{phase%%.*}}"
        local dec_part="${{phase##*.}}"
        printf "%02d.%s" "$int_part" "$dec_part"
    else
        printf "%02d" "$phase"
    fi
}}

PADDED=$(pad_phase "$PHASE")

# Find phase directory
PHASE_DIR=""
for dir in "$PHASES_DIR"/"$PADDED"-*/; do
    if [ -d "$dir" ]; then
        PHASE_DIR="$dir"
        break
    fi
done

if [ -z "$PHASE_DIR" ]; then
    log "Phase $PHASE: No phase directory found matching $PADDED-*. Skipping."
    exit 0
fi

# Check for plan files
PLAN_COUNT=$(find "$PHASE_DIR" -maxdepth 1 -name "$PADDED-*-PLAN.md" 2>/dev/null | wc -l | tr -d ' ')
if [ "$PLAN_COUNT" -eq 0 ]; then
    log "Phase $PHASE: No plan files found. Needs planning first. Skipping."
    exit 0
fi

# Check autonomous flag — skip if any plan has autonomous: false
for plan_file in "$PHASE_DIR"/"$PADDED"-*-PLAN.md; do
    if [ -f "$plan_file" ]; then
        # Extract frontmatter and check autonomous field
        if sed -n '/^---$/,/^---$/p' "$plan_file" | grep -q '^autonomous: false'; then
            log "Phase $PHASE: Plan $(basename "$plan_file") has autonomous: false. Needs human input. Skipping."
            exit 0
        fi
    fi
done

# Check dependency phases have passing verification
check_dependency() {{
    local dep_phase="$1"
    local dep_padded
    dep_padded=$(pad_phase "$dep_phase")

    local dep_dir=""
    for dir in "$PHASES_DIR"/"$dep_padded"-*/; do
        if [ -d "$dir" ]; then
            dep_dir="$dir"
            break
        fi
    done

    if [ -z "$dep_dir" ]; then
        log "Phase $PHASE: Dependency phase $dep_phase directory not found. Waiting."
        return 1
    fi

    local verification_file="$dep_dir/$dep_padded-VERIFICATION.md"
    if [ ! -f "$verification_file" ]; then
        log "Phase $PHASE: Dependency phase $dep_phase has no VERIFICATION.md. Waiting."
        return 1
    fi

    # Check status: passed in YAML frontmatter
    if ! sed -n '/^---$/,/^---$/p' "$verification_file" | grep -q '^status: passed'; then
        log "Phase $PHASE: Dependency phase $dep_phase verification not passed. Waiting."
        return 1
    fi

    return 0
}}

# Determine dependencies based on phase number
if [[ "$PHASE" == *.* ]]; then
    # Decimal phase depends on parent integer
    PARENT_INT="${{PHASE%%.*}}"
    if ! check_dependency "$PARENT_INT"; then
        exit 0
    fi
else
    # Integer phase depends on previous integer
    PREV_INT=$((PHASE - 1))
    if [ "$PREV_INT" -ge 1 ]; then
        if ! check_dependency "$PREV_INT"; then
            exit 0
        fi
    fi
fi

# All checks passed — execute the phase
log "Phase $PHASE: All prerequisites met. Starting execution."
log "Phase $PHASE: Running: claude -p '/gsd:execute-phase $PHASE --auto' $PROJECT"

claude -p "/gsd:execute-phase $PHASE --auto" "$PROJECT" >> "$LOG_FILE" 2>&1
EXIT_CODE=$?

if [ $EXIT_CODE -eq 0 ]; then
    log "Phase $PHASE: Execution completed successfully (exit code 0)."
else
    log "Phase $PHASE: Execution finished with exit code $EXIT_CODE."
fi

exit $EXIT_CODE
"##
    )
}

/// Get the path where the wrapper script should be written
pub fn wrapper_script_path(project_path: &Path) -> std::path::PathBuf {
    project_path
        .join(".planning")
        .join("gsd-cron-wrapper.sh")
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_wrapper_contains_project_path() {
        let path = PathBuf::from("/home/user/myproject");
        let script = generate_wrapper_script(&path);

        assert!(script.contains("/home/user/myproject"));
        assert!(script.contains("#!/usr/bin/env bash"));
        assert!(script.contains("PHASE=\"$1\""));
        assert!(script.contains("claude -p"));
        assert!(script.contains("gsd:execute-phase"));
    }

    #[test]
    fn test_wrapper_contains_dependency_check() {
        let path = PathBuf::from("/tmp/project");
        let script = generate_wrapper_script(&path);

        assert!(script.contains("check_dependency"));
        assert!(script.contains("status: passed"));
        assert!(script.contains("VERIFICATION.md"));
    }

    #[test]
    fn test_wrapper_contains_autonomous_check() {
        let path = PathBuf::from("/tmp/project");
        let script = generate_wrapper_script(&path);

        assert!(script.contains("autonomous: false"));
    }

    #[test]
    fn test_wrapper_script_path() {
        let project = PathBuf::from("/home/user/project");
        let path = wrapper_script_path(&project);
        assert_eq!(
            path,
            PathBuf::from("/home/user/project/.planning/gsd-cron-wrapper.sh")
        );
    }
}
